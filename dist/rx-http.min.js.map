{"version":3,"sources":["rx-http.js","utilities.js","headers.js","response.js","request.js","interceptors.js","xhr-provider.js","http.js"],"names":["root","factory","define","amd","exports","module","require","RxHttp","Rx","_","Cookies","this","isFile","value","toString","call","isFormData","isBlob","Response","xhr","lazy","_value","isUndefined","isFunction","_this","status","statusText","headers","getAllResponseHeaders","header","name","body","response","Request","config","method","Object","assign","query","isObject","timeout","retries","execute","provider","RequestInterceptorChain","interceptors","accept","reject","defaultRequest","request","good","defaultRequestError","error","bad","failure","remaining","recover","step","rest","err","isEmpty","interceptor","head","tail","transform","requestError","next","partial","run","success","ResponseInterceptorChain","defaultResponse","defaultResponseError","responseError","XHRProvider","registerEvents","observable","progressHandler","type","evt","onNext","progress","exceptionHandler","attempt","onError","onCompleted","upload","addEventListener","HTTP_EVENTS","UPLOAD_PROGRESS","DOWNLOAD_PROGRESS","successHandler","transformed","RESPONSE_RECEIVED","arguments","length","undefined","XmlHttpRequest","open","url","isInteger","keys","forEach","headerName","setRequestHeader","send","stream","Observable","create","share","uploadProgress","filter","map","downloadProgress","Http","generateRequestMethod","options","settings","defaults","baseUrl","isString","count","values","isArray","addInterceptor","push","removeInterceptor","remove","i","get","trace","post","put","patch","BROWSER_METHODS","Interceptors","BodyTransformer","_request","_x","_x2","_x3","apply","json","JSON","stringify","XSRF","_request2","_x4","_x5","_x6","xsrfToken","xsrfCookieName","xsrfHeader","xsrfHeaderName","ErrorHandling","_response","MethodOverride","_request3","_x7","_x8","_x9","originalMethod","some","m","thisIsNode","process","release","search","Error"],"mappings":"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","file":"rx-http.min.js","sourcesContent":[";(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['rx', 'lodash', 'js-cookie'], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('rx'), require('lodash'), require('js-cookie'));\n  } else {\n    root.RxHttp = factory(root.Rx, root._, root.Cookies);\n  }\n}(this, function(Rx, _, Cookies) {\n'use strict';\n\nfunction isFile(value) {\n  return toString.call(value) === '[object File]';\n}\n\nfunction isFormData(value) {\n  return toString.call(value) === '[object FormData]';\n}\n\nfunction isBlob(value) {\n  return toString.call(value) === '[object Blob]';\n}\n\nvar Headers = {\n\n  CONTENT_TYPE: \"Content-Type\"\n\n};\n\n/**\n * Immutable response container\n * @class\n */\nfunction Response(xhr) {\n  var _this = this;\n\n  function lazy(value) {\n    var _value = void 0;\n\n    return function () {\n      if (_.isUndefined(value)) {\n        if (_.isFunction(value)) {\n          _value = value();\n        } else {\n          _value = value;\n        }\n      }\n\n      return _value;\n    };\n  }\n\n  this.status = lazy(xhr.status);\n\n  this.statusText = lazy(xhr.statusText);\n\n  this.headers = lazy(xhr.getAllResponseHeaders);\n\n  this.header = function (name) {\n    return _this.headers()[name];\n  };\n\n  this.body = lazy(xhr.response);\n}\n\n/**\n * A Request should only ever be created by an instance of {@link Http}\n * @class\n * @param {Object} config - Override default settings for this Request only.\n * @private\n */\nfunction Request(config) {\n  /** @method\n   * @name method\n   * @param {string} [value] - The HTTP method for this request\n   * @returns {string|Request} - If value is specified, sets the HTTP method\n   * for this request and returns the current Request.  If value is ommitted,\n   * returns the current HTTP method\n   */\n  this.method = function (value) {\n    if (_.isUndefined(value)) {\n      return config.method;\n    } else {\n      config.method = value;\n      return this;\n    }\n  };\n\n  /** @method\n   * @name header\n   * @param {string} name - The name of the header\n   * @param {string} [value] - The value to assign to the header\n   * @returns {string|Request} - If value is specified, sets the header\n   * and returns the current Request.  If value is ommitted, returns the\n   * value for the header.\n   */\n  this.header = function (name, value) {\n    if (_.isUndefined(value)) {\n      return config.headers[name];\n    } else {\n      config.headers[name] = value.toString();\n      return this;\n    }\n  };\n\n  /** @method\n   * @name headers\n   * @param {Object} [value] - The hash of headers to send with this request.\n   * Replaces any existing headers\n   * @returns {object|Request} - If value is specified, sets the headers\n   * and returns the current Request.  If value is ommitted, returns a copy\n   * of the current headers.\n   */\n  this.headers = function (value) {\n    if (_.isUndefined(value)) {\n      return Object.assign({}, config.headers);\n    } else {\n      config.headers = value;\n      return this;\n    }\n  };\n\n  /** @method\n   * @name query\n   * @param {string|object} [name] - The name of the query-string parameter\n   * @param [value] - The value of the query-string parameter\n   * @returns {object|string|Request} -\n   * If no parameters are specified - returns a copy of the entire query hash.\n   * @example\n   * {{\n   *   request.query() // returns { \"foo\": \"bar\" }\n   * }}\n   * If only name is specified, and name is a string - returns the value for the key in the query hash.\n   * @example\n   * {{\n   *    request.query(\"foo\") // returns \"bar\"\n   * }}\n   * If only name is specified, and name is an object - replaces the entire query hash\n   * and returns the current Request.\n   * @example\n   * {{\n   *    request.query({ \"foo\": \"bar\", \"baz\": 1 }).execute()\n   * }}\n   * If name and value are specified - sets the value of name in the query hash\n   * and returns the current Request.\n   * @example\n   * {{\n   *   request.query(\"foo\", \"bar\").execute()\n   * }}\n   */\n  this.query = function (name, value) {\n    if (_.isUndefined(name)) {\n\n      if (_.isUndefined(value)) {\n\n        if (_.isObject(name)) {\n          config.query = name;\n          return this;\n        } else {\n          return config.query[name];\n        }\n      } else {\n        config.query[name] = value;\n        return this;\n      }\n    } else {\n      return Object.assign({}, config.query);\n    }\n  };\n\n  /** @method\n   * @name body\n   * @param {Object|FormData|Blob|File|string} [value] - The body for this request\n   * @returns - If value is specified, sets the body\n   * for this request and returns the current Request.  If value is ommitted,\n   * returns the current body\n   */\n  this.body = function (value) {\n    if (_.isUndefined(value)) {\n      return config.body;\n    } else {\n      config.body = value;\n      return this;\n    }\n  };\n\n  /** @method\n   * @name timeout\n   * @param {number} [value] - The number of milliseconds to wait before the request times out.\n   * @returns {number|Request} - If value is specified, sets the timeout\n   * for this request and returns the current Request.  If value is ommitted,\n   * returns the current timeout.\n   */\n  this.timeout = function (value) {\n    if (_.isUndefined(value)) {\n      return config.timeout;\n    } else {\n      config.timeout = value;\n      return this;\n    }\n  };\n\n  /** @method\n   * @name retries\n   * @param {number} [value] - The number of times this request will be retried on failure.\n   * @returns {number|Request} - If value is specified, sets the number of retries\n   * for this request and returns the current Request.  If value is ommitted,\n   * returns the current number of retries.\n   */\n  this.retries = function (value) {\n    if (_.isUndefined(value)) {\n      return config.retries;\n    } else {\n      config.retries = value;\n      return this;\n    }\n  };\n\n  /** @method\n   * @name execute\n   * @returns {Object} - Executes the request and returns an object containing\n   * the response, uploadProgress, and downloadProgress streams.\n   * @example\n   * {{\n   *    var streams = request.execute();\n   *    streams.response.forEach((response) => console.log(response));\n   *    streams.uploadProgress.forEach((event) => console.log(event));\n   *    streams.downloadProgress.forEach((event) => console.log(event));\n   * }}\n   */\n  this.execute = function () {\n    return config.provider(this);\n  };\n}\n\nvar BROWSER_METHODS = ['GET', 'POST'];\n\nvar Interceptors = {\n\n  BodyTransformer: {\n    request: function (_request) {\n      function request(_x, _x2, _x3) {\n        return _request.apply(this, arguments);\n      }\n\n      request.toString = function () {\n        return _request.toString();\n      };\n\n      return request;\n    }(function (request, accept, reject) {\n      var body = request.body();\n\n      if (_.isObject(body) && !isFile(body) && !isFormData(body) && !isBlob(body)) {\n        var json = JSON.stringify(body);\n        request.body(json);\n      }\n\n      accept(request);\n    })\n  },\n\n  XSRF: {\n    request: function (_request2) {\n      function request(_x4, _x5, _x6) {\n        return _request2.apply(this, arguments);\n      }\n\n      request.toString = function () {\n        return _request2.toString();\n      };\n\n      return request;\n    }(function (request, accept, reject) {\n      var xsrfToken = Cookies.get(request.xsrfCookieName());\n      var xsrfHeader = request.xsrfHeaderName();\n\n      if (_.isString(xsrfToken)) {\n        request.header(xsrfHeader, xsrfToken);\n      }\n\n      accept(request);\n    })\n  },\n\n  ErrorHandling: {\n    response: function response(_response, accept, reject) {\n      if (_response.status() / 100 === 2) {\n        accept(_response);\n      } else {\n        reject(_response);\n      }\n    }\n  },\n\n  MethodOverride: {\n    request: function (_request3) {\n      function request(_x7, _x8, _x9) {\n        return _request3.apply(this, arguments);\n      }\n\n      request.toString = function () {\n        return _request3.toString();\n      };\n\n      return request;\n    }(function (request, accept, reject) {\n      var originalMethod = request.method();\n\n      if (!BROWSER_METHODS.some(function (m) {\n        return m === originalMethod;\n      })) {\n        request.method('POST').header('X-HTTP-Method-Override', originalMethod);\n      }\n\n      accept(request);\n    })\n  }\n};\n\n/**\n * Runs the request interceptors, and requestError interceptors if necessary.\n * @class\n * @param {Object[]} interceptors - The array of interceptors to be run\n * @param {Function} accept - Callback that is invoked with the final request\n * object after all interceptors have run successfully.\n * @param {Function} reject - Callback that is invoked with an error object\n * if all of the interceptors fail to recover from an error.\n */\nfunction RequestInterceptorChain(interceptors, accept, reject) {\n  /**\n   * Pass-through accept for the request.\n   */\n  function defaultRequest(request, good) {\n    good(request);\n  }\n\n  /**\n   * Immediately rejects the error without trying to recover.\n   */\n  function defaultRequestError(error, good, bad) {\n    bad(error);\n  }\n\n  /**\n   * Handler for a rejected interceptor.  Runs requestError interceptor for\n   * all interceptors following the failure, in an attempt to recover.\n   * If one of the interceptors manages to recover, hop back into the next\n   * interceptor after the initial failure.\n   */\n  function failure(remaining, recover) {\n    return function (error) {\n      function step(rest, err) {\n        if (!_.isEmpty(rest)) {\n          var interceptor = _.head(rest);\n          var tail = _.tail(rest);\n          var transform = interceptor.requestError || defaultRequestError;\n          var next = _.partial(step, tail);\n\n          transform(err, recover, next);\n        } else {\n          reject(err);\n        }\n      }\n\n      step();\n    };\n  }\n\n  /** @method\n   * Runs the request through the chain of request interceptors\n   * @name run\n   */\n  this.run = function (request) {\n    function step(remaining, next) {\n      if (!_.isEmpty(remaining)) {\n        var interceptor = _.head(remaining);\n        var tail = _.tail(remaining);\n        var transform = interceptor.request || defaultRequest;\n        var success = _.partial(step, tail);\n\n        transform(request, success, failure(tail, success));\n      } else {\n        accept(request);\n      }\n    }\n\n    step(interceptors, request);\n  };\n}\n\n/**\n * Runs the response interceptors, and responseError interceptors if necessary.\n * @class\n * @param {Object[]} interceptors - The array of interceptors to be run\n * @param {Function} accept - Callback that is invoked with the final response\n * object after all interceptors have run successfully.\n * @param {Function} reject - Callback that is invoked with an error object\n * if all of the interceptors fail to recover from an error.\n */\nfunction ResponseInterceptorChain(interceptors, accept, reject) {\n  /**\n   * Pass-through accept for the response.\n   */\n  function defaultResponse(response, good) {\n    good(request);\n  }\n\n  /**\n   * Immediately rejects the error without trying to recover.\n   */\n  function defaultResponseError(error, good, bad) {\n    bad(error);\n  }\n\n  /**\n   * Handler for a rejected interceptor.  Runs responseError interceptor for\n   * all interceptors following the failure, in an attempt to recover.\n   * If one of the interceptors manages to recover, hop back into the next\n   * interceptor after the initial failure.\n   */\n  function failure(remaining, recover) {\n    return function (error) {\n      function step(rest, err) {\n        if (!_.isEmpty(rest)) {\n          var interceptor = _.head(rest);\n          var tail = _.tail(rest);\n          var transform = interceptor.responseError || defaultResponseError;\n          var next = _.partial(step, tail);\n\n          transform(err, recover, next);\n        } else {\n          reject(err);\n        }\n      }\n\n      step();\n    };\n  }\n\n  /** @method\n   * Runs the response through the chain of response interceptors\n   * @name run\n   */\n  this.run = function (response) {\n    function step(remaining, next) {\n      if (!_.isEmpty(remaining)) {\n        var interceptor = _.head(remaining);\n        var tail = _.tail(remaining);\n        var transform = interceptor.response || defaultResponse;\n        var success = _.partial(step, tail);\n\n        transform(response, success, failure(tail, success));\n      } else {\n        accept(response);\n      }\n    }\n\n    step(interceptors, request);\n  };\n}\n\nvar HTTP_EVENTS = {\n\n  UPLOAD_PROGRESS: 'UPLOAD_PROGRESS',\n\n  DOWNLOAD_PROGRESS: 'DOWNLOAD_PROGRESS',\n\n  RESPONSE_RECEIVED: 'RESPONSE_RECEIVED'\n\n};\n\nfunction XHRProvider(request) {\n  function registerEvents(xhr, observable, retries) {\n\n    function progressHandler(type, evt) {\n      observable.onNext({ type: type, progress: evt });\n    }\n\n    function exceptionHandler(evt) {\n      if (retries > 0) {\n        attempt(observable, retries - 1);\n      } else {\n        observable.onError(evt);\n        observable.onCompleted();\n      }\n    }\n\n    if (xhr.upload) {\n      xhr.upload.addEventListener('progress', _.partial(progressHandler, HTTP_EVENTS.UPLOAD_PROGRESS));\n      xhr.upload.addEventListener('error', exceptionHandler);\n      xhr.upload.addEventListener('abort', exceptionHandler);\n    }\n\n    xhr.addEventListener('progress', _.partial(progressHandler, HTTP_EVENTS.DOWNLOAD_PROGRESS));\n    xhr.addEventListener('error', exceptionHandler);\n    xhr.addEventListener('abort', exceptionHandler);\n    xhr.addEventListener('load', function (evt) {\n      var response = new Response(xhr);\n      var interceptors = request.interceptors();\n      var successHandler = function successHandler(transformed) {\n        observable.onNext({ type: HTTP_EVENTS.RESPONSE_RECEIVED, response: transformed });\n      };\n\n      new ResponseInterceptorChain(interceptors, successHandler, exceptionHandler).run(response);\n    });\n  }\n\n  function attempt(observable) {\n    var remaining = arguments.length <= 1 || arguments[1] === undefined ? request.retries() : arguments[1];\n\n\n    var xhr = new XmlHttpRequest();\n\n    registerEvents(xhr, observable, remaining);\n\n    xhr.open(request.method(), request.url());\n\n    if (_.isInteger(request.timeout())) {\n      xhr.timeout = request.timeout();\n    }\n\n    var headers = request.headers();\n    Object.keys(headers).forEach(function (headerName) {\n      xhr.setRequestHeader(headerName, headers[headerName]);\n    });\n\n    var interceptors = request.interceptors();\n    var success = function success(transformed) {\n      return xhr.send(transformed.body());\n    };\n    var failure = function failure(error) {\n      observable.onError(error);\n      observable.onCompleted();\n    };\n    new RequestInterceptorChain(interceptors, success, failure).run(request);\n  }\n\n  var stream = Rx.Observable.create(attempt).share();\n\n  var uploadProgress = stream.filter(function (evt) {\n    return evt.type === HTTP_EVENTS.UPLOAD_PROGRESS;\n  }).map(function (evt) {\n    return evt.progress;\n  });\n\n  var downloadProgress = stream.filter(function (evt) {\n    return evt.type === HTTP_EVENTS.DOWNLOAD_PROGRESS;\n  }).map(function (evt) {\n    return evt.progress;\n  });\n\n  var response = stream.filter(function (evt) {\n    return evt.type === HTTP_EVENTS.RESPONSE_RECEIVED;\n  }).map(function (evt) {\n    return evt.response;\n  });\n\n  return {\n    uploadProgress: uploadProgress,\n    downloadProgress: downloadProgress,\n    response: response\n  };\n}\n\n/**\n * An HTTP client.\n * @class\n * @param {Object} [options] - A hash of settings for this client.\n */\nfunction Http() {\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n  var settings = _.assign({}, Http.defaults, options);\n\n  /** @method\n   * @name timeout\n   * @param {number} [value] - The request timeout in milliseconds\n   * @returns {number|Http} - If value is specified, updates the default request\n   * timeout for all requests created with this client, and returns the client\n   * instance.  If value is ommitted, returns the current timeout value.\n   */\n  this.timeout = function (value) {\n    if (_.isInteger(value)) {\n      settings.timeout = value;\n      return this;\n    } else {\n      return settings.timeout;\n    }\n  };\n\n  /** @method\n   * @name baseUrl\n   * @param {string|Http} [url] - the base URL applied by default to all\n   * requests from this client.\n   * @returns {string|Http} - If url is specified, updates the default baseUrl\n   * for all requests created with this client, and returns the client instance.\n   * If value is ommitted, returns the current baseUrl.\n   */\n  this.baseUrl = function (url) {\n    if (_.isString(url)) {\n      settings.baseUrl = url;\n      return this;\n    } else {\n      return settings.url;\n    }\n  };\n\n  /** @method\n   * @name retries\n   * @param {number} [count] - The number of retries allowed\n   * @returns {number|Http} - If count is specified, sets the default number\n   * of retries allowed for requests from this client, and returns the client\n   * instance.  If count is ommitted, returns the current value.\n   */\n  this.retries = function (count) {\n    if (_.isInteger(count)) {\n      settings.retries = count;\n      return this;\n    } else {\n      return settings.retries;\n    }\n  };\n\n  /** @method\n   * @name interceptors\n   * @param {Object[]} [values] - An array of interceptors.\n   * @returns {Object[]|Http} - If values is specified, replaces the default\n   * interceptors for all requests from this client, and returns the client\n   * instance.  If values is ommitted, returns the current array of\n   * interceptors.\n   */\n  this.interceptors = function (values) {\n    if (_.isArray(values)) {\n      settings.interceptors = values;\n      return this;\n    } else {\n      return settings.interceptors;\n    }\n  };\n\n  /** @method\n   * @name addInterceptor\n   * @param {Object} interceptor - Add the interceptor to the end of the\n   * chain of interceptors.\n   * @return {Http} - The current client instance.\n   */\n  this.addInterceptor = function (interceptor) {\n    settings.interceptors.push(interceptor);\n    return this;\n  };\n\n  /** @method\n   * @name removeInterceptor\n   * @param interceptor - Remove the interceptor from the chain of interceptors.\n   * @returns {Http} - The current client instance.\n   */\n  this.removeInterceptor = function (interceptor) {\n    settings.interceptors = _.remove(settings.interceptors, function (i) {\n      return i === interceptor;\n    });\n    return this;\n  };\n\n  /** @method\n  * @name request\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).request('/some/stuff', {\n  *      method: 'POST',\n  *      body: { foo: \"bar\", baz: 1 },\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  var request = this.request = function (url) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    // TODO: parse URI.  merge query-string with value from settings\n    return new Request(settings);\n  };\n\n  /** @method\n  * @name head\n  * Helper method for request.  Automatically sets method to HEAD.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).head('/some/stuff', {\n  *      retries: 2,\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.head = generateRequestMethod('HEAD');\n\n  /** @method\n  * @name get\n  * Helper method for request.  Automatically sets method to GET.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).get('/some/stuff', {\n  *      retries: 2\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.get = generateRequestMethod('GET');\n\n  /** @method\n  * @name options\n  * Helper method for request.  Automatically sets method to OPTIONS.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).head('/some/stuff', {\n  *      retries: 2,\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.options = generateRequestMethod('OPTIONS');\n\n  /** @method\n  * @name delete\n  * Helper method for request.  Automatically sets method to DELETE.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).delete('/some/stuff', {\n  *      retries: 2,\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.delete = generateRequestMethod('DELETE');\n\n  /** @method\n  * @name trace\n  * Helper method for request.  Automatically sets method to TRACE.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).trace('/some/stuff', {\n  *      retries: 2,\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.trace = generateRequestMethod('TRACE');\n\n  /** @method\n  * @name post\n  * Helper method for request.  Automatically sets method to POST.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).post('/some/stuff', {\n  *      body: { foo: \"bar\", baz: 1 },\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.post = generateRequestMethod('POST');\n\n  /** @method\n  * @name put\n  * Helper method for request.  Automatically sets method to PUT.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).put('/some/stuff', {\n  *      body: { foo: \"bar\", baz: 1 },\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.put = generateRequestMethod('PUT');\n\n  /** @method\n  * @name patch\n  * Helper method for request.  Automatically sets method to PATCH.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).patch('/some/stuff', {\n  *      body: { foo: \"bar\", baz: 1 },\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.patch = generateRequestMethod('PATCH');\n\n  function generateRequestMethod(method) {\n    return function (url) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      return request(url, _.assign({ method: method }, options));\n    };\n  }\n}\n\nvar provider = function () {\n  var thisIsNode = !_.isUndefined(process) && !_.isUndefined(process.release) && !_.isUndefined(process.release.name) && process.release.name.search(/node|io.js/) !== -1;\n\n  if (thisIsNode) throw new Error(\"Node.js is not yet supported!\");else return XHRProvider;\n}();\n\nHttp.defaults = {\n  baseUrl: '',\n  retries: 0,\n  timeout: 30000,\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n  interceptors: [Interceptors.MethodOverride, Interceptors.BodyTransformer, Interceptors.XSRF, Interceptors.ErrorHandling],\n  provider: provider\n};\nreturn Http;\n}));\n","function isFile(value) {\n  return toString.call(value) === '[object File]';\n}\n\nfunction isFormData(value) {\n  return toString.call(value) === '[object FormData]';\n}\n\nfunction isBlob(value) {\n  return toString.call(value) === '[object Blob]';\n}\n","const Headers = {\n\n  CONTENT_TYPE: \"Content-Type\"\n\n}\n","/**\n * Immutable response container\n * @class\n */\nfunction Response(xhr) {\n  function lazy(value) {\n    let _value\n\n    return function() {\n      if (_.isUndefined(value)) {\n        if (_.isFunction(value)) {\n          _value = value()\n        } else {\n          _value = value\n        }\n      }\n\n      return _value\n    };\n  }\n\n  this.status = lazy(xhr.status);\n\n  this.statusText = lazy(xhr.statusText);\n\n  this.headers = lazy(xhr.getAllResponseHeaders);\n\n  this.header = (name) => this.headers()[name];\n\n  this.body = lazy(xhr.response);\n}\n","/**\n * A Request should only ever be created by an instance of {@link Http}\n * @class\n * @param {Object} config - Override default settings for this Request only.\n * @private\n */\nfunction Request(config) {\n  /** @method\n   * @name method\n   * @param {string} [value] - The HTTP method for this request\n   * @returns {string|Request} - If value is specified, sets the HTTP method\n   * for this request and returns the current Request.  If value is ommitted,\n   * returns the current HTTP method\n   */\n  this.method = function(value) {\n    if (_.isUndefined(value)) {\n      return config.method\n    } else {\n      config.method = value;\n      return this;\n    }\n  }\n\n  /** @method\n   * @name header\n   * @param {string} name - The name of the header\n   * @param {string} [value] - The value to assign to the header\n   * @returns {string|Request} - If value is specified, sets the header\n   * and returns the current Request.  If value is ommitted, returns the\n   * value for the header.\n   */\n  this.header = function(name, value) {\n    if (_.isUndefined(value)) {\n      return config.headers[name];\n    } else {\n      config.headers[name] = value.toString();\n      return this;\n    }\n  }\n\n  /** @method\n   * @name headers\n   * @param {Object} [value] - The hash of headers to send with this request.\n   * Replaces any existing headers\n   * @returns {object|Request} - If value is specified, sets the headers\n   * and returns the current Request.  If value is ommitted, returns a copy\n   * of the current headers.\n   */\n  this.headers = function(value) {\n    if (_.isUndefined(value)) {\n      return Object.assign({}, config.headers);\n    } else {\n      config.headers = value;\n      return this;\n    }\n  }\n\n  /** @method\n   * @name query\n   * @param {string|object} [name] - The name of the query-string parameter\n   * @param [value] - The value of the query-string parameter\n   * @returns {object|string|Request} -\n   * If no parameters are specified - returns a copy of the entire query hash.\n   * @example\n   * {{\n   *   request.query() // returns { \"foo\": \"bar\" }\n   * }}\n   * If only name is specified, and name is a string - returns the value for the key in the query hash.\n   * @example\n   * {{\n   *    request.query(\"foo\") // returns \"bar\"\n   * }}\n   * If only name is specified, and name is an object - replaces the entire query hash\n   * and returns the current Request.\n   * @example\n   * {{\n   *    request.query({ \"foo\": \"bar\", \"baz\": 1 }).execute()\n   * }}\n   * If name and value are specified - sets the value of name in the query hash\n   * and returns the current Request.\n   * @example\n   * {{\n   *   request.query(\"foo\", \"bar\").execute()\n   * }}\n   */\n  this.query = function(name, value) {\n    if (_.isUndefined(name)) {\n\n      if (_.isUndefined(value)) {\n\n        if (_.isObject(name)) {\n          config.query = name;\n          return this;\n        } else {\n          return config.query[name];\n        }\n\n      } else {\n        config.query[name] = value;\n        return this;\n      }\n\n    } else {\n      return Object.assign({}, config.query);\n    }\n  }\n\n  /** @method\n   * @name body\n   * @param {Object|FormData|Blob|File|string} [value] - The body for this request\n   * @returns - If value is specified, sets the body\n   * for this request and returns the current Request.  If value is ommitted,\n   * returns the current body\n   */\n  this.body = function(value) {\n    if (_.isUndefined(value)) {\n      return config.body;\n    } else {\n      config.body = value;\n      return this;\n    }\n  }\n\n  /** @method\n   * @name timeout\n   * @param {number} [value] - The number of milliseconds to wait before the request times out.\n   * @returns {number|Request} - If value is specified, sets the timeout\n   * for this request and returns the current Request.  If value is ommitted,\n   * returns the current timeout.\n   */\n  this.timeout = function(value) {\n    if (_.isUndefined(value)) {\n      return config.timeout;\n    } else {\n      config.timeout = value;\n      return this;\n    }\n  }\n\n  /** @method\n   * @name retries\n   * @param {number} [value] - The number of times this request will be retried on failure.\n   * @returns {number|Request} - If value is specified, sets the number of retries\n   * for this request and returns the current Request.  If value is ommitted,\n   * returns the current number of retries.\n   */\n  this.retries = function(value) {\n    if (_.isUndefined(value)) {\n      return config.retries;\n    } else {\n      config.retries = value;\n      return this;\n    }\n  }\n\n  /** @method\n   * @name execute\n   * @returns {Object} - Executes the request and returns an object containing\n   * the response, uploadProgress, and downloadProgress streams.\n   * @example\n   * {{\n   *    var streams = request.execute();\n   *    streams.response.forEach((response) => console.log(response));\n   *    streams.uploadProgress.forEach((event) => console.log(event));\n   *    streams.downloadProgress.forEach((event) => console.log(event));\n   * }}\n   */\n  this.execute = function() {\n    return config.provider(this);\n  }\n}\n","const BROWSER_METHODS = ['GET', 'POST'];\n\nconst Interceptors = {\n\n  BodyTransformer: {\n    request: (request, accept, reject) => {\n      const body = request.body();\n\n      if (_.isObject(body) && !isFile(body) && !isFormData(body) && !isBlob(body)) {\n        const json = JSON.stringify(body);\n        request.body(json);\n      }\n\n      accept(request);\n    }\n  },\n\n  XSRF: {\n    request: (request, accept, reject) => {\n      const xsrfToken = Cookies.get(request.xsrfCookieName());\n      const xsrfHeader = request.xsrfHeaderName();\n\n      if (_.isString(xsrfToken)) {\n        request.header(xsrfHeader, xsrfToken);\n      }\n\n      accept(request);\n    }\n  },\n\n  ErrorHandling: {\n    response: (response, accept, reject) => {\n      if (response.status() / 100 === 2) {\n        accept(response);\n      } else {\n        reject(response);\n      }\n    }\n  },\n\n  MethodOverride: {\n    request: (request, accept, reject) => {\n      const originalMethod = request.method();\n\n      if (!BROWSER_METHODS.some(m => m === originalMethod)) {\n        request\n          .method('POST')\n          .header('X-HTTP-Method-Override', originalMethod);\n      }\n\n      accept(request);\n    }\n  }\n};\n\n/**\n * Runs the request interceptors, and requestError interceptors if necessary.\n * @class\n * @param {Object[]} interceptors - The array of interceptors to be run\n * @param {Function} accept - Callback that is invoked with the final request\n * object after all interceptors have run successfully.\n * @param {Function} reject - Callback that is invoked with an error object\n * if all of the interceptors fail to recover from an error.\n */\nfunction RequestInterceptorChain(interceptors, accept, reject) {\n  /**\n   * Pass-through accept for the request.\n   */\n  function defaultRequest(request, good) {\n    good(request);\n  }\n\n  /**\n   * Immediately rejects the error without trying to recover.\n   */\n  function defaultRequestError(error, good, bad) {\n    bad(error);\n  }\n\n  /**\n   * Handler for a rejected interceptor.  Runs requestError interceptor for\n   * all interceptors following the failure, in an attempt to recover.\n   * If one of the interceptors manages to recover, hop back into the next\n   * interceptor after the initial failure.\n   */\n  function failure(remaining, recover) {\n    return function(error) {\n      function step(rest, err) {\n        if (!_.isEmpty(rest)) {\n          const interceptor = _.head(rest);\n          const tail = _.tail(rest);\n          const transform = interceptor.requestError || defaultRequestError;\n          const next = _.partial(step, tail);\n\n          transform(err, recover, next);\n        } else {\n          reject(err);\n        }\n      }\n\n      step();\n    }\n  }\n\n  /** @method\n   * Runs the request through the chain of request interceptors\n   * @name run\n   */\n  this.run = function(request) {\n    function step(remaining, next) {\n      if (!_.isEmpty(remaining)) {\n        const interceptor = _.head(remaining);\n        const tail = _.tail(remaining);\n        const transform = interceptor.request || defaultRequest;\n        const success = _.partial(step, tail);\n\n        transform(request, success, failure(tail, success));\n      } else {\n        accept(request);\n      }\n    }\n\n    step(interceptors, request);\n  }\n}\n\n/**\n * Runs the response interceptors, and responseError interceptors if necessary.\n * @class\n * @param {Object[]} interceptors - The array of interceptors to be run\n * @param {Function} accept - Callback that is invoked with the final response\n * object after all interceptors have run successfully.\n * @param {Function} reject - Callback that is invoked with an error object\n * if all of the interceptors fail to recover from an error.\n */\nfunction ResponseInterceptorChain(interceptors, accept, reject) {\n  /**\n   * Pass-through accept for the response.\n   */\n  function defaultResponse(response, good) {\n    good(request);\n  }\n\n  /**\n   * Immediately rejects the error without trying to recover.\n   */\n  function defaultResponseError(error, good, bad) {\n    bad(error);\n  }\n\n  /**\n   * Handler for a rejected interceptor.  Runs responseError interceptor for\n   * all interceptors following the failure, in an attempt to recover.\n   * If one of the interceptors manages to recover, hop back into the next\n   * interceptor after the initial failure.\n   */\n  function failure(remaining, recover) {\n    return function(error) {\n      function step(rest, err) {\n        if (!_.isEmpty(rest)) {\n          const interceptor = _.head(rest);\n          const tail = _.tail(rest);\n          const transform = interceptor.responseError || defaultResponseError;\n          const next = _.partial(step, tail);\n\n          transform(err, recover, next);\n        } else {\n          reject(err);\n        }\n      }\n\n      step();\n    }\n  }\n\n  /** @method\n   * Runs the response through the chain of response interceptors\n   * @name run\n   */\n  this.run = function(response) {\n    function step(remaining, next) {\n      if (!_.isEmpty(remaining)) {\n        const interceptor = _.head(remaining);\n        const tail = _.tail(remaining);\n        const transform = interceptor.response || defaultResponse;\n        const success = _.partial(step, tail);\n\n        transform(response, success, failure(tail, success));\n      } else {\n        accept(response);\n      }\n    }\n\n    step(interceptors, request);\n  }\n}\n","const HTTP_EVENTS = {\n\n  UPLOAD_PROGRESS: 'UPLOAD_PROGRESS',\n\n  DOWNLOAD_PROGRESS: 'DOWNLOAD_PROGRESS',\n\n  RESPONSE_RECEIVED: 'RESPONSE_RECEIVED'\n\n};\n\nfunction XHRProvider(request) {\n  function registerEvents(xhr, observable, retries) {\n\n    function progressHandler(type, evt) {\n      observable.onNext({ type, progress: evt });\n    }\n\n    function exceptionHandler(evt) {\n      if (retries > 0) {\n        attempt(observable, retries - 1);\n      } else {\n        observable.onError(evt);\n        observable.onCompleted();\n      }\n    }\n\n    if (xhr.upload) {\n      xhr.upload.addEventListener('progress', _.partial(progressHandler, HTTP_EVENTS.UPLOAD_PROGRESS));\n      xhr.upload.addEventListener('error', exceptionHandler);\n      xhr.upload.addEventListener('abort', exceptionHandler);\n    }\n\n    xhr.addEventListener('progress', _.partial(progressHandler, HTTP_EVENTS.DOWNLOAD_PROGRESS));\n    xhr.addEventListener('error', exceptionHandler);\n    xhr.addEventListener('abort', exceptionHandler);\n    xhr.addEventListener('load', (evt) => {\n      const response = new Response(xhr);\n      const interceptors = request.interceptors();\n      const successHandler = function(transformed) {\n        observable.onNext({ type: HTTP_EVENTS.RESPONSE_RECEIVED, response: transformed});\n      }\n\n      new ResponseInterceptorChain(interceptors, successHandler, exceptionHandler)\n        .run(response);\n    });\n\n  }\n\n  function attempt(observable, remaining = request.retries()) {\n\n    const xhr = new XmlHttpRequest();\n\n    registerEvents(xhr, observable, remaining);\n\n    xhr.open(request.method(), request.url());\n\n    if (_.isInteger(request.timeout())) {\n      xhr.timeout = request.timeout();\n    }\n\n    const headers = request.headers();\n    Object.keys(headers).forEach((headerName) => {\n      xhr.setRequestHeader(headerName, headers[headerName]);\n    });\n\n    const interceptors = request.interceptors();\n    const success = (transformed) => xhr.send(transformed.body());\n    const failure = (error) => {\n      observable.onError(error);\n      observable.onCompleted();\n    }\n    new RequestInterceptorChain(interceptors, success, failure)\n      .run(request);\n  }\n\n  const stream = Rx.Observable.create(attempt).share();\n\n  const uploadProgress = stream\n    .filter(evt => evt.type === HTTP_EVENTS.UPLOAD_PROGRESS)\n    .map(evt => evt.progress);\n\n  const downloadProgress = stream\n    .filter(evt => evt.type === HTTP_EVENTS.DOWNLOAD_PROGRESS)\n    .map(evt => evt.progress);\n\n  const response = stream\n    .filter(evt => evt.type === HTTP_EVENTS.RESPONSE_RECEIVED)\n    .map(evt => evt.response);\n\n  return {\n    uploadProgress,\n    downloadProgress,\n    response\n  };\n}\n","/**\n * An HTTP client.\n * @class\n * @param {Object} [options] - A hash of settings for this client.\n */\nfunction Http(options = {}) {\n  const settings = _.assign({}, Http.defaults, options);\n\n  /** @method\n   * @name timeout\n   * @param {number} [value] - The request timeout in milliseconds\n   * @returns {number|Http} - If value is specified, updates the default request\n   * timeout for all requests created with this client, and returns the client\n   * instance.  If value is ommitted, returns the current timeout value.\n   */\n  this.timeout = function(value) {\n    if (_.isInteger(value)) {\n      settings.timeout = value;\n      return this;\n    } else {\n      return settings.timeout;\n    }\n  }\n\n  /** @method\n   * @name baseUrl\n   * @param {string|Http} [url] - the base URL applied by default to all\n   * requests from this client.\n   * @returns {string|Http} - If url is specified, updates the default baseUrl\n   * for all requests created with this client, and returns the client instance.\n   * If value is ommitted, returns the current baseUrl.\n   */\n  this.baseUrl = function(url) {\n    if (_.isString(url)) {\n      settings.baseUrl = url;\n      return this;\n    } else {\n      return settings.url;\n    }\n  }\n\n  /** @method\n   * @name retries\n   * @param {number} [count] - The number of retries allowed\n   * @returns {number|Http} - If count is specified, sets the default number\n   * of retries allowed for requests from this client, and returns the client\n   * instance.  If count is ommitted, returns the current value.\n   */\n  this.retries = function(count) {\n    if (_.isInteger(count)) {\n      settings.retries = count;\n      return this;\n    } else {\n      return settings.retries;\n    }\n  }\n\n  /** @method\n   * @name interceptors\n   * @param {Object[]} [values] - An array of interceptors.\n   * @returns {Object[]|Http} - If values is specified, replaces the default\n   * interceptors for all requests from this client, and returns the client\n   * instance.  If values is ommitted, returns the current array of\n   * interceptors.\n   */\n  this.interceptors = function(values) {\n    if (_.isArray(values)) {\n      settings.interceptors = values;\n      return this;\n    } else {\n      return settings.interceptors;\n    }\n  }\n\n  /** @method\n   * @name addInterceptor\n   * @param {Object} interceptor - Add the interceptor to the end of the\n   * chain of interceptors.\n   * @return {Http} - The current client instance.\n   */\n  this.addInterceptor = function(interceptor) {\n    settings.interceptors.push(interceptor);\n    return this;\n  }\n\n  /** @method\n   * @name removeInterceptor\n   * @param interceptor - Remove the interceptor from the chain of interceptors.\n   * @returns {Http} - The current client instance.\n   */\n  this.removeInterceptor = function(interceptor) {\n    settings.interceptors = _.remove(settings.interceptors, (i) => i === interceptor);\n    return this;\n  }\n\n  /** @method\n  * @name request\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).request('/some/stuff', {\n  *      method: 'POST',\n  *      body: { foo: \"bar\", baz: 1 },\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  const request = this.request = function(url, options = {}) {\n    // TODO: parse URI.  merge query-string with value from settings\n    return new Request(settings);\n  }\n\n  /** @method\n  * @name head\n  * Helper method for request.  Automatically sets method to HEAD.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).head('/some/stuff', {\n  *      retries: 2,\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.head = generateRequestMethod('HEAD')\n\n  /** @method\n  * @name get\n  * Helper method for request.  Automatically sets method to GET.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).get('/some/stuff', {\n  *      retries: 2\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.get = generateRequestMethod('GET');\n\n  /** @method\n  * @name options\n  * Helper method for request.  Automatically sets method to OPTIONS.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).head('/some/stuff', {\n  *      retries: 2,\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.options = generateRequestMethod('OPTIONS');\n\n  /** @method\n  * @name delete\n  * Helper method for request.  Automatically sets method to DELETE.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).delete('/some/stuff', {\n  *      retries: 2,\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.delete = generateRequestMethod('DELETE');\n\n  /** @method\n  * @name trace\n  * Helper method for request.  Automatically sets method to TRACE.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).trace('/some/stuff', {\n  *      retries: 2,\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.trace = generateRequestMethod('TRACE');\n\n  /** @method\n  * @name post\n  * Helper method for request.  Automatically sets method to POST.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).post('/some/stuff', {\n  *      body: { foo: \"bar\", baz: 1 },\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.post = generateRequestMethod('POST');\n\n  /** @method\n  * @name put\n  * Helper method for request.  Automatically sets method to PUT.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).put('/some/stuff', {\n  *      body: { foo: \"bar\", baz: 1 },\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.put = generateRequestMethod('PUT');\n\n  /** @method\n  * @name patch\n  * Helper method for request.  Automatically sets method to PATCH.\n  * @param {string} url - the URL where the request will be sent.\n  * @param {Object} [options] - add/override settings for this request.\n  * @return {@link Request}\n  * @example\n  * {{\n  *    new Http({ baseUrl: 'http://mydomain.com', timeout: 5000 }).patch('/some/stuff', {\n  *      body: { foo: \"bar\", baz: 1 },\n  *      timeout: 10000\n  *    })\n  * }}\n  **/\n  this.patch = generateRequestMethod('PATCH');\n\n  function generateRequestMethod(method) {\n    return function(url, options = {}) {\n      return request(url, _.assign({ method }, options));\n    }\n  }\n}\n\nconst provider = (function() {\n  const thisIsNode =\n    !_.isUndefined(process) &&\n      !_.isUndefined(process.release) &&\n      !_.isUndefined(process.release.name) &&\n      process.release.name.search(/node|io.js/) !== -1;\n\n  if (thisIsNode) throw new Error(\"Node.js is not yet supported!\");\n  else return XHRProvider;\n})();\n\nHttp.defaults = {\n  baseUrl: '',\n  retries: 0,\n  timeout: 30000,\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n  interceptors: [\n    Interceptors.MethodOverride,\n    Interceptors.BodyTransformer,\n    Interceptors.XSRF,\n    Interceptors.ErrorHandling\n  ],\n  provider\n};\n"],"sourceRoot":"/source/"}