{"version":3,"sources":["rx-http.js","deep-copy.js","http-events.js","response.js","request.js","xhr-provider.js","http.js"],"names":["root","factory","define","amd","exports","module","require","RxHttp","Rx","this","_classCallCheck","instance","Constructor","TypeError","deepCopy","object","copyObject","obj","clone","Object","keys","forEach","key","step","Array","isArray","map","_typeof","Response","xhr","lazy","value","_value","undefined","_this","status","statusText","headers","getAllResponseHeaders","header","name","body","Request","options","_this2","timeout","retries","method","url","assign","query","execute","provider","XHRProvider","request","registerEvents","observable","progressHandler","type","evt","onNext","progress","exceptionHandler","attempt","onError","onCompleted","upload","addEventListener","HTTP_EVENTS","UPLOAD_PROGRESS","DOWNLOAD_PROGRESS","response","RESPONSE_RECEIVED","remaining","arguments","length","window","XmlHTTPRequest","open","headerName","setRequestHeader","send","stream","Observable","create","share","uploadProgress","filter","downloadProgress","_createClass","defineProperties","target","props","i","descriptor","enumerable","configurable","writable","defineProperty","protoProps","staticProps","prototype","Symbol","iterator","constructor","BROWSER_METHODS","identity","a","RequestBuilder","interceptor","toString","settings","some","m","process","release","Error","Http","defaults","toLowerCase"],"mappings":"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","file":"rx-http.min.js","sourcesContent":[";(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['rx'], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('rx'));\n  } else {\n    root.RxHttp = factory(root.Rx);\n  }\n}(this, function(Rx) {\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction deepCopy(object) {\n  function copyObject(obj) {\n    var clone = {};\n    Object.keys(obj).forEach(function (key) {\n      clone[key] = step(obj[key]);\n    });\n    return clone;\n  }\n\n  function step(obj) {\n    if (Array.isArray(obj)) return obj.map(step);else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') return copyObject(obj);else return obj;\n  }\n\n  return step(object);\n}\n\nvar HTTP_EVENTS = {\n  UPLOAD_PROGRESS: 'UPLOAD_PROGRESS',\n  DOWNLOAD_PROGRESS: 'DOWNLOAD_PROGRESS',\n  RESPONSE_RECEIVED: 'RESPONSE_RECEIVED'\n};\n\n/**\n* Immutable response container\n**/\nfunction Response(xhr) {\n  var _this = this;\n\n  function lazy(value) {\n    var _value = void 0;\n\n    return function () {\n      if (value === undefined) {\n        if (typeof value === 'function') {\n          _value = value();\n        } else {\n          _value = value;\n        }\n      }\n\n      return _value;\n    };\n  }\n\n  this.status = lazy(xhr.status);\n  this.statusText = lazy(xhr.statusText);\n  this.headers = lazy(xhr.getAllResponseHeaders());\n  this.header = function (name) {\n    return _this.headers()[name];\n  };\n\n  //TODO: detect/transform response body\n  this.body = lazy(function () {});\n}\n\n/**\n* Immutable request to be executed\n**/\nfunction Request(options) {\n  var _this2 = this;\n\n  this.timeout = function () {\n    return _this2.options.timeout;\n  };\n  this.retries = function () {\n    return _this2.options.retries;\n  };\n  this.method = function () {\n    return options.method;\n  };\n  this.url = function () {\n    return options.url;\n  };\n  this.body = function () {\n    return options.body;\n  };\n  this.header = function (name) {\n    return options.headers[name];\n  };\n  this.headers = function () {\n    return Object.assign({}, options.headers);\n  };\n  this.query = function (name) {\n    if (name === undefined) return Object.assign({}, options.query);else return _this2.options.query[name];\n  };\n\n  this.execute = function () {\n    return options.provider(_this2);\n  };\n}\n\nfunction XHRProvider(request) {\n  function registerEvents(xhr, observable, retries) {\n    var progressHandler = function progressHandler(type) {\n      return function (evt) {\n        observable.onNext({ type: type, progress: evt });\n      };\n    };\n\n    var exceptionHandler = function exceptionHandler(evt) {\n      if (retries > 0) {\n        attempt(observable, retries - 1);\n      } else {\n        observable.onError(evt);\n        observable.onCompleted();\n      }\n    };\n\n    if (xhr.upload) {\n      xhr.upload.addEventListener('progress', progressHandler(HTTP_EVENTS.UPLOAD_PROGRESS));\n      xhr.upload.addEventListener('error', exceptionHandler);\n      xhr.upload.addEventListener('abort', exceptionHandler);\n    }\n\n    xhr.addEventListener('progress', progressHandler(HTTP_EVENTS.DOWNLOAD_PROGRESS));\n    xhr.addEventListener('error', exceptionHandler);\n    xhr.addEventListener('abort', exceptionHandler);\n    xhr.addEventListener('load', function (evt) {\n      var response = new Response(xhr);\n      observable.onNext({ type: HTTP_EVENTS.RESPONSE_RECEIVED, response: response });\n    });\n  }\n\n  function attempt(observable) {\n    var remaining = arguments.length <= 1 || arguments[1] === undefined ? request.retries() : arguments[1];\n\n    var xhr = new window.XmlHTTPRequest();\n    registerEvents(xhr, observable, remaining);\n\n    xhr.open(request.method(), request.url());\n\n    if (!!request.timeout() && typeof request.timeout() === 'number') {\n      xhr.timeout = request.timeout();\n    }\n\n    var headers = request.headers();\n    Object.keys(headers).forEach(function (headerName) {\n      xhr.setRequestHeader(headerName, headers[headerName]);\n    });\n\n    // TODO: consider dealing with xhr.responseType\n    // TODO: detect/transform request body\n    xhr.send(request.body());\n  }\n\n  var stream = Rx.Observable.create(attempt).share();\n\n  var uploadProgress = stream.filter(function (evt) {\n    return evt.type === HTTP_EVENTS.UPLOAD_PROGRESS;\n  }).map(function (evt) {\n    return evt.progress;\n  });\n\n  var downloadProgress = stream.filter(function (evt) {\n    return evt.type === HTTP_EVENTS.DOWNLOAD_PROGRESS;\n  }).map(function (evt) {\n    return evt.progress;\n  });\n\n  var response = stream.filter(function (evt) {\n    return evt.type === HTTP_EVENTS.RESPONSE_RECEIVED;\n  }).map(function (evt) {\n    return evt.response;\n  });\n\n  return {\n    uploadProgress: uploadProgress,\n    downloadProgress: downloadProgress,\n    response: response\n  };\n}\n\nvar BROWSER_METHODS = ['GET', 'POST'];\nvar identity = function identity(a) {\n  return a;\n};\n/**\n* Mutable builder with a fluent-interface for creating immutable Requests\n**/\n\nvar RequestBuilder = function () {\n  function RequestBuilder(retries, timeout, provider, interceptor) {\n    _classCallCheck(this, RequestBuilder);\n\n    this.options = Object.assign({}, { retries: retries, timeout: timeout, provider: provider, interceptor: interceptor });\n  }\n\n  _createClass(RequestBuilder, [{\n    key: 'header',\n    value: function header(name, value) {\n      if (value === undefined) return this.options.headers[name];else {\n        this.options.headers[name] = value.toString();\n        return this;\n      }\n    }\n  }, {\n    key: 'headers',\n    value: function headers(value) {\n      if (value === undefined) return Object.assign({}, this.options.headers);else {\n        this.options.headers = Object.assign({}, this.options.headers, value);\n        return this;\n      }\n    }\n  }, {\n    key: 'query',\n    value: function query(name, value) {\n      if (value === undefined) {\n        if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n          this.options.query = name;\n          return this;\n        } else {\n          return this.options.query[name];\n        }\n      } else {\n        this.options.query[name] = value.toString();\n        return this;\n      }\n    }\n  }, {\n    key: 'body',\n    value: function body(value) {\n      if (value === undefined) return this.options.body;else {\n        this.options.body = value;\n        return this;\n      }\n    }\n  }, {\n    key: 'timeout',\n    value: function timeout(value) {\n      if (value === undefined) return this.options.timeout;else {\n        this.options.timeout = value;\n        return this;\n      }\n    }\n  }, {\n    key: 'retries',\n    value: function retries(value) {\n      if (value === undefined) return this.options.retries;else {\n        this.options.retries = value;\n        return this;\n      }\n    }\n  }, {\n    key: 'build',\n    value: function build() {\n      var settings = deepCopy(this.options);\n\n      if (!BROWSER_METHODS.some(function (m) {\n        return m === settings.method;\n      })) {\n        settings.method = 'POST';\n        settings.headers['X-HTTP-Method-Override'] = this.options.method;\n      }\n\n      return new Request(settings);\n    }\n  }]);\n\n  return RequestBuilder;\n}();\n\nvar provider = function () {\n  if (typeof process !== 'undefined' && typeof process.release !== 'undefined' && process.release.name === 'node') {\n    throw new Error('Node.js support coming soon');\n  } else {\n    return XHRProvider;\n  }\n}();\n\n/**\n* Factory method for RequestBuilder\n**/\nvar Http = {\n  request: function request(url, method) {\n    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    var settings = {\n      url: url,\n      method: method,\n      retries: Http.defaults.retries,\n      timeout: Http.defaults.timeout,\n      provider: Http.defaults.provider,\n      interceptor: Http.defaults.interceptor\n    };\n    return new RequestBuilder(settings);\n  },\n\n  defaults: {\n    retries: 0,\n    timeout: 30000,\n    interceptor: identity,\n    provider: provider\n  }\n};\n\n['GET', 'POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE', 'HEAD', 'TRACE'].forEach(function (method, i) {\n  Http[method.toLowerCase()] = function (url) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n    return Http.request(url, method, options);\n  };\n});\nreturn Http;\n}));\n","function deepCopy(object) {\n  function copyObject(obj) {\n    const clone = {};\n    Object.keys(obj).forEach(key => {\n      clone[key] = step(obj[key]);\n    });\n    return clone;\n  }\n\n  function step(obj) {\n    if (Array.isArray(obj)) return obj.map(step);\n    else if (typeof obj === 'object') return copyObject(obj);\n    else return obj;\n  }\n\n  return step(object);\n}\n","const HTTP_EVENTS = {\n  UPLOAD_PROGRESS: 'UPLOAD_PROGRESS',\n  DOWNLOAD_PROGRESS: 'DOWNLOAD_PROGRESS',\n  RESPONSE_RECEIVED: 'RESPONSE_RECEIVED'\n};\n","/**\n* Immutable response container\n**/\nfunction Response(xhr) {\n  function lazy(value) {\n    let _value\n\n    return function() {\n      if (value === undefined) {\n        if (typeof value === 'function') {\n          _value = value()\n        } else {\n          _value = value\n        }\n      }\n\n      return _value\n    };\n  }\n\n  this.status = lazy(xhr.status)\n  this.statusText = lazy(xhr.statusText)\n  this.headers = lazy(xhr.getAllResponseHeaders())\n  this.header = (name) => this.headers()[name]\n\n  //TODO: detect/transform response body\n  this.body = lazy(() => {\n\n  })\n}\n","/**\n* Immutable request to be executed\n**/\nfunction Request(options) {\n  this.timeout = () => this.options.timeout;\n  this.retries = () => this.options.retries;\n  this.method = () => options.method;\n  this.url = () => options.url;\n  this.body = () => options.body;\n  this.header = (name) => options.headers[name];\n  this.headers = () => Object.assign({}, options.headers);\n  this.query = (name) => {\n    if (name === undefined) return Object.assign({}, options.query);\n    else return this.options.query[name];\n  };\n\n  this.execute = () => options.provider(this);\n}\n","function XHRProvider(request) {\n  function registerEvents(xhr, observable, retries) {\n    const progressHandler = (type) => (evt) => {\n      observable.onNext({ type, progress: evt });\n    };\n\n    const exceptionHandler = (evt) => {\n      if (retries > 0) {\n        attempt(observable, retries - 1);\n      } else {\n        observable.onError(evt);\n        observable.onCompleted();\n      }\n    };\n\n    if (xhr.upload) {\n      xhr.upload.addEventListener('progress', progressHandler(HTTP_EVENTS.UPLOAD_PROGRESS));\n      xhr.upload.addEventListener('error', exceptionHandler);\n      xhr.upload.addEventListener('abort', exceptionHandler);\n    }\n\n    xhr.addEventListener('progress', progressHandler(HTTP_EVENTS.DOWNLOAD_PROGRESS));\n    xhr.addEventListener('error', exceptionHandler);\n    xhr.addEventListener('abort', exceptionHandler);\n    xhr.addEventListener('load', (evt) => {\n      const response = new Response(xhr);\n      observable.onNext({ type: HTTP_EVENTS.RESPONSE_RECEIVED, response });\n    });\n  }\n\n  function attempt(observable, remaining = request.retries()) {\n    const xhr = new window.XmlHTTPRequest();\n    registerEvents(xhr, observable, remaining);\n\n    xhr.open(request.method(), request.url());\n\n    if (!!request.timeout() && typeof request.timeout() === 'number') {\n      xhr.timeout = request.timeout();\n    }\n\n    const headers = request.headers();\n    Object.keys(headers).forEach((headerName) => {\n      xhr.setRequestHeader(headerName, headers[headerName]);\n    });\n\n    // TODO: consider dealing with xhr.responseType\n    // TODO: detect/transform request body\n    xhr.send(request.body());\n  }\n\n  const stream = Rx.Observable.create(attempt).share();\n\n  const uploadProgress = stream\n    .filter(evt => evt.type === HTTP_EVENTS.UPLOAD_PROGRESS)\n    .map(evt => evt.progress);\n\n  const downloadProgress = stream\n    .filter(evt => evt.type === HTTP_EVENTS.DOWNLOAD_PROGRESS)\n    .map(evt => evt.progress);\n\n  const response = stream\n    .filter(evt => evt.type === HTTP_EVENTS.RESPONSE_RECEIVED)\n    .map(evt => evt.response);\n\n  return {\n    uploadProgress,\n    downloadProgress,\n    response\n  };\n}\n","const BROWSER_METHODS = ['GET', 'POST'];\nconst identity = (a) => a;\n/**\n* Mutable builder with a fluent-interface for creating immutable Requests\n**/\nclass RequestBuilder {\n  constructor(retries, timeout, provider, interceptor) {\n    this.options = Object.assign({}, { retries, timeout, provider, interceptor });\n  }\n\n  header(name, value) {\n    if (value === undefined) return this.options.headers[name];\n    else {\n      this.options.headers[name] = value.toString();\n      return this;\n    }\n  }\n\n  headers(value) {\n    if (value === undefined) return Object.assign({}, this.options.headers);\n    else {\n      this.options.headers = Object.assign({}, this.options.headers, value);\n      return this;\n    }\n  }\n\n  query(name, value) {\n    if (value === undefined) {\n      if (typeof name === 'object') {\n        this.options.query = name;\n        return this;\n      } else {\n        return this.options.query[name];\n      }\n    } else {\n      this.options.query[name] = value.toString();\n      return this;\n    }\n  }\n\n  body(value) {\n    if (value === undefined) return this.options.body;\n    else {\n      this.options.body = value;\n      return this;\n    }\n  }\n\n  timeout(value) {\n    if (value === undefined) return this.options.timeout;\n    else {\n      this.options.timeout = value;\n      return this;\n    }\n  }\n\n  retries(value) {\n    if (value === undefined) return this.options.retries;\n    else {\n      this.options.retries = value;\n      return this;\n    }\n  }\n\n  build() {\n    const settings = deepCopy(this.options);\n\n    if (!BROWSER_METHODS.some(m => m === settings.method)) {\n      settings.method = 'POST';\n      settings.headers['X-HTTP-Method-Override'] = this.options.method;\n    }\n\n    return new Request(settings);\n  }\n}\n\nconst provider = (function () {\n  if (typeof process !== 'undefined' && typeof process.release !== 'undefined' && process.release.name === 'node') {\n    throw new Error('Node.js support coming soon');\n  } else {\n    return XHRProvider;\n  }\n})();\n\n/**\n* Factory method for RequestBuilder\n**/\nconst Http = {\n  request(url, method, options = {}) {\n    const settings = {\n      url,\n      method,\n      retries: Http.defaults.retries,\n      timeout: Http.defaults.timeout,\n      provider: Http.defaults.provider,\n      interceptor: Http.defaults.interceptor\n    };\n    return new RequestBuilder(settings);\n  },\n  defaults: {\n    retries: 0,\n    timeout: 30000,\n    interceptor: identity,\n    provider\n  }\n};\n\n['GET', 'POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE', 'HEAD', 'TRACE'].forEach((method, i) => {\n  Http[method.toLowerCase()] = (url, options = {}) => Http.request(url, method, options);\n});\n"],"sourceRoot":"/source/"}